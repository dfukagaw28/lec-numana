---
jupytext:
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

# 数の表現

我々が数を表現するとき，日常的には，**10 進法**（decimal numeral system）を用いる。
10 進法は，人類が持つ 10 本の指と相性が良い。
計算機は，電圧の高低や磁気方向のような 2 値の情報を最小単位とするため，**2 進法**（binary numeral system）と相性が良い。
2 値の最小単位を **ビット**（bit）[^bit]とよぶ。

[^bit]: 10 進法における 1 桁の数字を英語で "digit" というが，「2 進法の digit」つまり "binary digit" が "bit" という語の由来とされている。1946年の論文 {cite}`shannon_1948` の中で "bit" という語を用いた情報理論の父シャノン（Claude E. Shannon, 1916-2001）によれば，"bit" という語を提案したのはアメリカの数学者・統計学者のジョン・テューキー（John W. Tukey, 1915-2000）である。

計算機では，あらかじめ定められた方法にしたがって，いくつかのビットを組み合わせて 1 つの数を表す。

現代の多くの計算機において，数を表現するときには以下の方式を組み合わせる[^binary]。
- 非負整数: 固定長整数
- 負の整数: 2 の補数
- 小数: 浮動小数点数

[^binary]: ある1つの数をビット列で表現する方法は一意ではなく，実際，歴史的には異なる表現方法が混在してきたが，そのような経緯はここでは述べず，執筆時点で一般的に通用する方式にしたがう。

以下では，本節で述べた用語について順に説明する。

## 10 進数と 2 進数

たとえば，10 進法で $123$ と表される数を 2 進法で表すと $1111011_{(2)}$ となる。
これは 7 個のビットで表現できる。
また，10 進法で $1234$ と表される数を 2 進法で表すと $10011010010_{(2)}$ となる。
これは 11 個のビットで表現できる。

10進整数 $123$ を 2 進数に変換するには，$2$ で割った余りを繰り返し求めればよい。
```{math}
  123 & = 61 \times 2 + {\color{red}1} \\
  61  & = 30 \times 2 + {\color{red}1} \\
  30  & = 15 \times 2 + {\color{red}0} \\
  15  & = \phantom{0}7 \times 2 + {\color{red}1} \\
  7   & = \phantom{0}3 \times 2 + {\color{red}1} \\
  3   & = \phantom{0}1 \times 2 + {\color{red}1} \\
  1   & = \phantom{0}0 \times 2 + {\color{red}1} \\
  & \therefore 123 = {\color{red}1111011}_{(2)}
```

同様の手順で 10 進整数 $1234$ を 2 進数に変換できる。

$1$ 未満の正の10進小数 $0.3$ を 2 進数に変換するには，$2$ を掛けて一の位を繰り返し取り出せばよい。
```{math}
  & 0.3 \times 2 = {\color{red}0}.6 \\
  & 0.6 \times 2 = {\color{red}1}.2 \\
  & 0.2 \times 2 = {\color{red}0}.4 \\
  & 0.4 \times 2 = {\color{red}0}.8 \\
  & 0.8 \times 2 = {\color{red}1}.6 \\
  & 0.6 \times 2 = {\color{red}1}.2 \\
  & \therefore 0.3 = 0.{\color{red}010011}\cdots_{(2)} = 0.0\dot{1}00\dot{1}_{(2)}
```
この例でも分かる通り，10進数の有限小数を2進数に変換した場合，必ずしも有限小数になるとは限らない。

```{prf:example}
:label: example-numerics-1

$12.34$ のように，整数部分と小数部分のどちらも含む数を2進数に変換するには，整数部分 $12$ と小数部分 $0.34$ に分けてそれぞれ変換すればよい。

つまり，整数部分 $12=1100_{(2)}$ と小数部分 $0.34=0.0101011\cdots_{(2)}$ から $12.34=1100.0101011\cdots_{(2)}$ となる。

$12.34$ は 10 進数では有限小数となるが，2進数では循環小数となる。
実際，$12.34=1100.0\dot{1}010111000010100011\dot{1}_{(2)}$ である。

一般に，10 進数で有限小数として表すことのできる数が 2 進数で有限小数で表すことができるとは限らない。10 進数で有限小数で表せない数は， 2 進数でも有限小数として表せない。
```

````{prf:example}
:label: example-numerics-2

2進数と10進数を相互に変換する機械的な作業は，
計算機 [^computer] を用いて実行するのが便利である。

[^computer]: ここでいう計算機（computer）とは，電卓（calculator）のことではなく，いわゆるコンピュータのことである。デスクトップ PC，ノート PC，タブレット，スマートフォンなどは計算機である。

ここでは， Python を用いた方法を解説する。プログラムを書かない方法 [^bin2dec] もあるが，機械的な作業というものはたいていプログラムにできる。ちょっとしたプログラムで解決する方法がある，という事実を知っておくと選択肢が広がる。

[^bin2dec]: インターネットで方法を調べると，オンラインの変換ツールがたくさん見つかるはずである。Web ブラウザでそのツールを開いて数字を入力すればよいだけで，たいへん便利である。ただし，オンラインの変換ツールがいつも有効であるわけではない。たとえば，変換したい数がたくさん（たとえば 10000 個）ある場合は，一つ一つ手入力をして結果を記録しているとかなりの手間がかかる。手入力の場合，どんなに頑張っても1個あたり1秒のスピードを上回ることはなく，全部で3時間以上かかってしまう。時間は大切である。

まず，10 進数を 2 進数に変換してみよう。
この目的に対しては，組み込み関数 [`bin()`](https://docs.python.org/ja/3/library/functions.html#bin) を用いるとよい。
関数 `bin()` の戻り値は文字列（`str` オブジェクト）である。

```python
s = bin(123)
print(s)      # => '0b1111011'
```

プログラミング言語 [Python](https://www.python.org/) では，先頭に `0b` を付けて 2 進数を表す。これは[整数リテラル](https://docs.python.org/ja/3/reference/lexical_analysis.html#integers)の仕様として定められている。

もし先頭の `0b` が邪魔である場合は，[フォーマット済み文字リテラル](https://docs.python.org/ja/3.8/tutorial/inputoutput.html#formatted-string-literals)（formatted string literals; f-string）を用いるのもよい。

```python
s = f'{123:b}'
print(s)        # => '1111011'
```

逆に，2進数を10進数に変換する方法を考えよう。上で述べた整数リテラルを用いて，整数を2進数によって与えることができる。当たり前であるが，出力は（人間のためのものであるから）原則として 10 進数で表示される。

```python
x = 0b1111011
print(x)       # => 123
```

ここで，変数 `x` の値は通常の整数（`int`）である。

文字列として 2 進数が与えられた場合に 10 進数に変換するには，以下のように [`int()` 関数](https://docs.python.org/ja/3/library/functions.html#int)を用いるとよい。

```python
s = '1111011'
x = int(s, base=2)
print(x)            # => 123
```
````

## 固定長整数

計算機で **自然数**（natural number）や **整数**（integer）を表現するとき，通常は固定長のビット列を用いる。
このような表現を **固定長整数**（fixed-precision integer）という。

整数のビット長としてよく用いられるのは 32 ビットや 64 ビットである。
稀に 8 ビットで数を表現することもあるが，この場合，$2^8=256$ 種類の数しか表現できない。
通常，8 ビットで表現するのは $0=00000000_{(2)}$ から $255=11111111_{(2)}$ までの **非負整数**（non-negative integer）[^非負整数]，あるいは，$-128$ から $+127$ までの整数である。より広範囲の数を扱うには，より多くのビットを用いる必要がある。

[^非負整数]: 日本の高校数学では，自然数を $1,2,3,\cdots$ と定義し，$0$ を要素として含めない。しかし一般には，自然数に $0$ を含めて定義することがある。たとえば Peano (Giuseppe Peano, 1858-1932) によって公理化された自然数は $0$ を含む。計算機科学においては，アドレスや配列の添え字など，$0$ を含む非負整数を頻繁に扱う。以下，本稿では，曖昧な「自然数」という表現を避け，「正整数」や「非負整数」という表現を用いることにする。

Python の組み込み整数型 `int` は **任意精度整数**（arbitrary-precision integer）であり無限の精度[^無限の精度]を持つ。

たとえば，$3^{100}$ や $3^{1000}$ のような計算を（近似でなく）厳密に行うことができる。

```{code-cell}
3 ** 100
```

固定長整数より多倍長整数の方が便利だが，通常は一定の精度で十分であること，また，計算効率は固定長整数の方が高いことなどの理由から，大規模な科学計算では固定長整数を利用することが多い。たとえば，Python の有名な数値計算ライブラリである [NumPy](https://numpy.org/) では整数を扱うとき内部で固定長整数を用いる。

[^無限の精度]: 実際には，計算機の記憶装置の容量（主記憶装置，二次記憶装置など）の制約を受ける。

## 2 の補数

計算機では，非負整数と整数をそれぞれ **符号なし整数**（unsigned integer）と **符号つき整数**（signed integer）で表現する。
符号なし整数は，2 進数で自然に表現できる。
符号つき整数については，符号なし整数に対して符号を表すビット（符号ビット）を 1 ビット追加する方法もあるが，より一般的なのは **2 の補数**（two's complement）を用いる方法である。

整数を $t$ ビットで表すとき，ある整数 $n$ の 2 の補数とは，正の整数 $2^t - n$ のことである。
たとえば，整数を 16 ビットで表すとき， $123=0000000001111011_{(2)}$ の 2 の補数は

$$
  2^{16} - 123 = 65413 = 1111111110000101_{(2)}
$$

である。
任意の整数 $n$ とその 2 の補数 $2^t-n$ の和は $2^n$ であるが，$2^n$ を 2 進数で表現するには $t+1$ ビットが必要であり，最上位ビットがあふれた結果，下位 $t$ ビットは $000\cdots 0_{(2)}$ となる。
これは，$n$ と $-n$ の和が $0$ になることに対応する。
```text
    0000 0000 0111 1011
+)  1111 1111 1000 0101
-----------------------
  1 0000 0000 0000 0000
```

8 ビットの符号つき整数を以下に示す。

```{list-table}
:header-rows: 1

* - $n$（10進数）
  - $n$（2進数）
  - $-n$（10進数）
  - $-n$（2進数）
* - +0
  - 0 000 0000
  - -0
  - 0 000 0000
* - +1
  - 0 000 0001
  - -1
  - 1 111 1111
* - +2
  - 0 000 0010
  - -2
  - 1 111 1110
* - +3
  - 0 000 0011
  - -3
  - 1 111 1101
* - +4
  - 0 000 0100
  - -4
  - 1 111 1100
* - ...
  - ...
  - ...
  - ...
* - +126
  - 0 111 1110
  - -126
  - 1 000 0010
* - +127
  - 0 111 1111
  - -127
  - 1 000 0001
* - +128
  - 該当なし
  - -128
  - 1 000 0000
```

2 の補数表現において，最上位ビットは符号ビットとして利用できる。
原則として正の数の最上位ビットは `0` であり，負の数の最上位ビットは `1` である。
ただし，正でも負でもない $0$ の最上位ビットが `0` である点に注意が必要である。
その影響で，表現できる正の数は負の数より 1 個少ない。
8 ビットの符号つき整数では，$-128$ が表現できる一方，$+128$ を表現することはできない。

通常は，より広い範囲の数を扱う必要があるため，より多くのビットを用いて符号つき整数を表す。
16 ビットであれば $-32{,}768$ から $+32{,}767$ までを表現できる。
32 ビットであれば $-2{,}147{,}483{,}648$ から $+2{,}147{,}483{,}647$ までを表現できる。
64 ビットであれば $-9{,}223{,}372{,}036{,}854{,}775{,}808$ から $+9{,}223{,}372{,}036{,}854{,}775{,}807$ までを表現できる。

Python で 2 の補数が用いられていることは，以下のようにビット反転演算子 `~` によって確認することができる。

```{code-cell}
[~0, ~(-1)]
```

## 浮動小数点数

小学校の算数では，小数を $123.456$ のように固定小数点の 10 進数で表現する。
高校の化学では，アボガドロ定数[^アボガドロ定数]を $6.02214076 \times 10^{23}$ のように習う。
後者のような表現方法を科学的表記法（scientific notation） あるいは浮動小数点表記（floating point expression）とよび，そのような方法で表現された数を **浮動小数点数**（floating point number）とよぶ。

[^アボガドロ定数]: 物質量 1 mol を構成する粒子の個数を示す定数。単位は $\text{mol}^{-1}$。厳密には，単位を含めたものがアボガドロ定数であり，単位を $\text{mol}^{-1}$ とした数値そのものはアボガドロ数とよび，区別することがある。ちなみに，日本化学会・化学工学会・新化学技術推進協会・日本化学工業協会の 4 団体は 10 月 23 日を「化学の日」と定めたが，これはアボガドロ数の指数部に由来する。

一般に，2 以上の整数 $\beta$ と正整数 $t$ に対して，$\beta$ 進 $t$ 桁の浮動小数点数は以下のように表される。

$$
  \pm (d_0 . d_1 d_2 \cdots d_{t-1})_{(\beta)} \times \beta^e
$$

この数は，以下の値を持つ。

$$
  \pm \Bigl( d_0 + \frac{d_1}{\beta^1} + \frac{d_2}{\beta^2} + \cdots + \frac{d_{t-1}}{\beta^{t-1}} \Bigr) \times \beta^e
$$

ここで，$\pm$ は $+$ または $-$ の **符号**（sign）であり，
$D=(d_0 . d_1 d_2 \cdots d_{t-1})_{(\beta)}$ を **仮数**（significand）とよび，$e$ を **指数**（exponent）とよぶ。
ただし，仮数の各桁 $d_i$ は $0$ から $\beta-1$ までの非負整数であり，指数 $e$ は整数である。
また，$\beta$ を **基数**（base）とよぶ。

基数 $\beta$ を固定した場合であっても，ある数 $x$ を浮動小数点数として表現する方法は唯一ではない。
たとえば，$123.456$ は以下のようにいくつかの表現を持つ。

```{math}
  0.00123456 \times 10^5 \\
  0.123456 \times 10^3 \\
  1.23456 \times 10^2
```

上の例を見ると分かるように，上位桁に $0$ が残っていると仮数部に余分な桁を必要とする。
仮数部の桁数 $t$ が同じであれば，最上位桁 $d_0$ が $0$ でないようにするのが最も効率が良い。
仮数部の最上位桁（一の位）$d_0$ が $0$ にならないように定めることで浮動小数点数は一意に定まる。
これを浮動小数点数の **正規化**（normalization） という。
ただし，例外として，数 $x$ が $0$ そのものである場合には $d_0=0$ となることは避けられない。

たとえば $123.456$ を 2 進 5 桁の浮動小数点数に変換してみよう（つまり $\beta=2$，$t=5$）。

1. まず，2 進数に変換する。$123.456=1111011.01110100101_{(2)}$
1. 仮数部と指数部に分ける。$123.456=1.11101101110100101_{(2)} \times 2^6$
1. 仮数部が 5 桁になるように丸める。$123.456 \approx 1.1111_{(2)} \times 2^6$

最後の **丸め**（rounding） については，いくつかの方針があり得る。
単純に考えれば，最も近い値に丸めるのが良さそうである。
ただし $1.00001_{(2)}$ を 5 桁で丸めるとき $1.0000_{(2)}$ と $1.0001_{(2)}$ のいずれとも距離は同じであるから，このような数をどちらに丸めるかについて基準を決めておく必要がある。10 進数でよく用いられる四捨五入の概念を応用し，2 進数でも「0 捨 1 入」という考え方が直感的には理解しやすいかもしれない。計算機では，多くの場合，**偶数への丸め**（round to even）という基準が用いられる。偶数への丸めでは，仮数部の最下位ビットが $0$ になるように丸めるため，0 捨 1 入とは異なる結果が得られる場合がある。丸めについては，のちほど改めて述べる。

上で見たように，無理数や循環小数のように小数点以下の桁が無限に続く場合，浮動小数点数で表現するためには値を丸める必要があり，その結果，真の値とのズレが生じる。
このズレのことを **丸め誤差**（rounding error, round-off error）とよぶ。
有限桁で表現できる有理数であっても，仮数部の桁数 $t$ が十分でない場合は丸め誤差が生じる点に注意が必要である。

````{prf:example}
:label: example-numerics-3

上の例において，10進数 $123.456$ を 2 進 5 桁の浮動小数点数に変換したときの丸め誤差を考えよう。

$123.456 \approx 1.1111_{(2)} \times 2^6$ であるが，$1.1111_{(2)} \times 2^6$ の正確な値は $124$ であるから，丸め誤差の大きさは $|124-123.456|=0.544$ である。$0.544 / 123.456 = 0.00440\cdots$ であるから，約0.44% の誤差といえる。
````

---
jupytext:
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

# Python プログラミング超入門

Python でプログラミングを行うにあたって，最低限必要と考えられる事項について述べる。
対象は，Python によるプログラミングが初めてである者も想定しているが，説明は必ずしも十分でなく省略している個所も多い。
途中で理解が困難な箇所にたびたび出会うかもしれない。
もし理解が困難な箇所に出会った場合は，そのままにせず，遠慮なく質問（授業中であれば挙手，授業時間外であれば e-class 掲示板や電子メールなど）して可能な限り解決を図ってほしい。

入門書にざっと目を通すのもお薦めである。幸いなことに，Web 上の教材も充実しているため，手元に入門書がなくてもオンラインで無料閲覧可能である。
Web 教材では最近以下のような資料が分かりやすいと話題になったようである。

- [東京大学『Pythonプログラミング入門』](https://utokyo-ipp.github.io/)

- [京都大学『プログラミング演習 Python 2021』](http://hdl.handle.net/2433/265460)

- [三谷純（筑波大学）『Python ゼロからはじめるプログラミング』](https://mitani.cs.tsukuba.ac.jp/book_support/python/)

- [岡崎直観（東京工業大学）『Python早見帳』](https://chokkan.github.io/python/index.html)

Web 上のさまざまなサイトで Python の「わかりやすい」説明があるが，きちんと勉強するのであれば，単に「わかりやすい」（と言われている／今の自分が感じる）説明を読んで終わりにせず，公式ドキュメントではどのように書かれているか，という点をあわせて確認することを強くお薦めする（時間が無ければ後回しでも構わないが，忘れてしまわないように）。
標準でないライブラリについても，各ライブラリの公式ドキュメントにあたる癖をつけるのが望ましい。

- [Python 公式ドキュメント（英語）](https://docs.python.org/3/)

  - [Python 公式ドキュメント（日本語）](https://docs.python.org/ja/3/)

## プログラミング環境

お薦めは [Colab（Google Colaboratory）](https://colab.research.google.com/) である。
Colab の使い方は，たとえば「[こちら](https://utokyo-ipp.github.io/1/1-0.html)」を参照されたい。
Colab を利用するためには Google アカウントでログインする必要がある。

より手軽に，アカウントなしで利用できるものに [paiza.io](https://paiza.io/ja) 等がある。
トップページで「[コード作成を試してみる（無料）](https://paiza.io/ja/projects/new)」ボタンをクリックし，左上の緑色のボタンでプログラミング言語「Python3」を選択したうえで，コードを書いて「実行（Ctrl+Enter）」するだけでプログラムを実行できる。
非常に手軽である。
実行したコードや結果はブラウザを閉じると消えてしまう。
残しておくためにはやはりアカウントを作成する必要がある。

オンラインサービスとしてのプログラミング環境は，初心者が使い始める際には便利であるが，一方で，問題もある。たとえば，インターネット接続が必須であるという点，ハードウェア（メモリやストレージなど）やソフトウェア（標準でない機能パッケージなど）のカスタマイズが難しい点，などが問題として挙げられる。

自身の PC に Python プログラミング環境を導入する場合は，たとえば，以下のサイトの説明が分かりやすい。

- [Python環境構築ガイド - python.jp](https://www.python.jp/install/install.html)

```{note}
個人的には，最初は Anaconda をインストールせずに Python のみをインストールするのがよいと思う。
最初からいろいろ入っているものを使うと，便利ではあるが，「自分が使っている道具が何であるか，何に由来するのか」が分かりづらくなるからである。
目的を果たすために足りないものを 1 つずつ補っていく過程で学ぶものは大きく，最初の段階でそれを捨てるのはもったいない。
そのうえ，Python 標準パッケージマネージャである pip や標準仮想環境である venv は Anaconda と相性が悪く，その点も初心者が戸惑う原因になっているように思う。
```

## 式・値

プログラムで簡単な計算をさせるには，そのまま計算式を書けばよい。

```{code-cell}
10 + 20
```

Python では，`10 + 20` のように数値と演算子を適切な順序に並べたものを **式**（expression）という。
`10` のような数値そのものも「式」である。
その他，数値以外のデータ（文字列や配列など）を扱うものや，関数呼び出しなども「式」である。

数学で計算式 $10+20$ を計算した結果は $30$ となる。Python の式も，それぞれ計算した結果を持つ。式は数値の計算に関するものとは限らないため計算でなく **評価**（evaluation）という。式を評価した結果，その式の **値**（value）が得られる。

対話的な実行環境（Python 標準の対話型インタプリタ，Jupyter Notebook，Google Colab 等）では，与えた式の値を自動的に表示してくれる。
もし表示されない場合は，以下のように `print()` 関数を利用するとよい。

```{code-cell}
print(10 + 20)
```

加算 `+`，減算 `-`，乗算 `*`，除算 `/` については算数の要領で記述するだけである。

注意が必要な点は，除算の結果（商）を小数で得たい場合は `123 / 7` のように `/` を使い，商の整数部分だけ得たい場合は `123 // 7` のように `//` を用いる点である。剰余（あまり）を求めたいときは `123 % 7` のように演算子 `%` を使う。

複数の式の結果を表示させたいときは，前述の `print()` 関数を用いるか，もしくは，式をコンマ（半角コンマ `,`）で区切る。

```{code-cell}
print(123 / 7)
print(123 // 7, 123 % 7)
```

```{code-cell}
123 / 7,    123 // 7,    123 % 7
```

Python の命令は基本的に行ごとに分かれており，上から下へ順に処理される。

対話的な実行環境で式の値が表示されるのは最後の行（最後に評価した式）だけである。

```{code-cell}
123 / 7   # この行の値は表示されない
123 // 7  # この行の値は表示されない
123 % 7
```

上の例において `#` から行末まで（`#` 自身を含む）は **コメント**（comment）である。計算機はコメントを無視するため，ここに何を書いてもよい。
プログラムの内容について理解を助けるためのメモを書くことが多い。

```{note}
多くのプログラミング言語において，空白文字は基本的に無視される。
ただし，いくつか例外がある。

たとえば，2文字以上からなる演算子 `//` の間に空白を入れて `/ /` のようにすると意味が変わってしまう（多くの場合，文法違反になる）。
また，Python ではインデント（行頭の空白）は重要な意味を持つため，行頭に空白が入るかどうかについては注意が必要である。

日本語を入力していると，つい全角空白 `　`（U+3000）を入力してしまうことがあるが，全角空白は半角空白とは異なる文字で，いずれも目には見えないため，問題が生じやすい。
プログラムを書くときは全角空白を絶対に使わない，基本的に日本語入力（IME）はオフにする，という習慣付けが重要である。
```

## 変数

演算の対象となるデータ（数値，文字列，など）を参照する際に「あの数字」「この文字列」では曖昧である。データに名前を付けて参照すると便利である。

プログラミングにおける **変数**（variable）とは，たとえるならば，特定のデータに結びつけられる名札（名前のラベル）のことである。あるいは，データを入れておくことのできる箱のことである[^variable]。

[^variable]: より正確には，変数とは，計算機プログラムが利用するメモリの番地のことである。「箱」の比喩は，直接参照を表現することに向いているが，間接参照を表現するためにはポインタの理解が必要となる。「名札」の比喩は，immutable object の参照について初学者の混同を招く可能性がある。

たとえば，次のような使い方ができる。

```{code-cell}
a = 10  # 変数 a に整数 10 を代入する（整数 10 に a という名前を付ける）
b = 20  # 変数 b に整数 20 を代入する（整数 20 に b という名前を付ける）
print(a + b)
```

```{code-cell}
pi = 3.14  # 変数 pi に小数 3.14 を代入する（小数 3.14 に pi という名前を付ける）
print(2 * pi)
```

上の例に示す通り，式の中で値の代わりに変数を用いることができる。

変数の名前を **識別子**（identifier） という。識別子には，1文字以上の半角英字を並べたものを使う[^identifier]。

[^identifier]: 名前はどんなものでもよい（プログラムの動作は変わらない）が，いくつかの制約がある。Python の場合，識別子の先頭以外の位置に `0` から`9` までの半角数字を使うこともできる。また，アンダースコア `_` を使うこともできる。ただし，アンダースコア `_` で始まる識別子は予約されており，特別な扱いを受ける場合がある。その他，プログラムの構文や演算子に用いられる予約語（キーワード）を識別子に利用することはできない。たとえば，`and` や `if` や `def` などを識別子に利用することはできない。Python 3 では全角のかな・漢字・記号を識別子に利用することができるが，まず使う機会はないし，よほどの事情がない限りは使うべきではない。

変数という箱に値を入れる操作を **代入**（assignment）とよぶ。
変数に初めて値を代入することを変数の **初期化**（initialization）とよぶ[^declaration]。

[^declaration]: Python では変数の宣言は不要である。初期化のタイミングで変数が利用可能になる。ただし関数内でグローバル変数を利用する際に，グローバル宣言が必要な場合がある。

初期化する前に変数を参照するとエラーが発生する。

```{code-cell}
:tags: [raises-exception]
print(c)
c = 10
```

変数に代入した値は，後でもう一度代入することによって変更できる。

```{code-cell}
print(a)
a = 3.14
print(a)
```

ここで，変数 `a` の最初の値は，以前に代入した値が残っていることに注意すること。

## 型

値には，整数・小数・文字列・配列など，いくつかの種類がある。
これを **型**（type）あるいは **クラス**（class）とよぶ。

Python の主な型には以下のようなものがある。

- 整数（integer）: `int`
- 浮動小数点数（floating point number）: `float`
- 文字列（string）: `str`
- 真理値（boolean）: `bool`
- リスト（list）: `list`

整数と小数の扱いには注意が必要である。
数学では $10$ と $10.0$ は全く同じ値であると考える。
Python では `10` と `10.0` は内部的に異なる。
したがって，表示される内容も異なる。

```{code-cell}
10
```

```{code-cell}
10.0
```

````{note}
以下のように型を調べることができる。

```python
print(type(10))    # => <class 'int'>
print(type(10.0))  # => <class 'float'>
```
````

上で見たように整数と小数は内部的には異なるが，数学的には両者は等しいため，プログラムでは等しいものとして扱うことが多い。

```{code-cell}
10 == 10.0
```

ここで，記号 `==` は演算子である。両辺の値を比較して等しければ `True`，そうでなければ `False` という値を返す。

```{warning}
`==` と `=` の違いに注意。
等価演算子 `==` は両辺が等しいかどうかを調べる演算子である。
代入演算子 `=` は右辺（式）の値を左辺（変数）に代入せよ，という命令文で用いられる。
```

Python では，変数は型を持たない。
同じ名前の変数に，さまざまな型を代入することができる。
このあたりは，C や Java などプログラミング言語によって扱いが大きく異なるため注意が必要である。

```{code-cell}
x = 10
print(type(x))
x = 3.14
print(type(x))
x = 'hello'
print(type(x))
```

```{note}
Python は変数に特定の型を定めない動的型付け（dynamic typing）方式を採用している。Python 3.5 以降では型ヒント（type hint）を利用することが可能となっており，特に，大きく複雑なプログラムでは有用である。ここでは型ヒントについて扱わない。
```

小数の定数を表現するには，`3.14` のような方法の他に

```
1.234e-5
```

のような指数表記（科学的表記）もある。

また，計算機特有の表現として `1.0` を `1.` と書くような表記もよく用いられる。 

## 文字列

任意の文字の並びを1つの値として扱うことができる。これを **文字列**（string）とよぶ。Python では文字列を表現するためには，一重引用符（シングルクォート; single quote） `'` あるいは二重引用符（ダブルクォート; double quote） `"` で囲めばよい。

```{code-cell}
s = 'hello'
print(s)
```

```{note}
引用符そのものは，文字列の内容に含まれない。
`'hello'` という表現が表す文字列データの内容は `h` から `o` までの 5 つの文字の並びである。

プログラム中でデータそのものを表現したものを **リテラル**（literal）という。
`'hello'` は文字列リテラルであり，`123` は整数リテラルである。

引用符を使わない場合， `123` のような「数字だけからなる文字列」が文字列であるのか整数であるのか区別できなくなる。
よって文字列リテラルに引用符は必要である。
```

文字列を一重引用符で囲む場合，文字列中に一重引用符を含めることができない。

```{code-cell}
:tags: [raises-exception]
s = 'Let's go!'    # エラーが発生する'
```

一重引用符を含む文字列を表現するには，二重引用符で囲めばよい。
逆に，二重引用符を含む文字列を表現するには，一重引用符で囲めばよい。

```{code-cell}
s = "Let's go!"
print(s)
s = 'She said "No."'
print(s)
```

一重引用符と二重引用符を両方含む文字列を表現する場合，そのままでは，どちらの引用符でも囲むことができない。そのような場合は，文字列中の引用符の前に半角バックスラッシュ `\` （back slack）を追加すればよい。

```{code-cell}
s = 'He said "I\'m fine."'
print(s)
```

```{note}
Python では半角バックスラッシュ `\` は **エスケープ文字**（escape character）として扱われる。エスケープ文字から始まる特定の文字の並びを **エスケープシーケンス**（escape sequence）とよぶ。
詳細は [Python 言語リファレンス](https://docs.python.org/ja/3/reference/lexical_analysis.html#string-and-bytes-literals)等を参照されたい。
```

```{warning}
歴史的な経緯から，日本語環境では[半角バックスラッシュ U+005C](https://ja.wiktionary.org/wiki/%5C) が[半角円記号 `¥` で表示される場合が多い。Unicode では半角円記号を別の文字 U+00A5 として定義している。これらは混同しやすいため，慣れないうちは注意すること。
```

Python では文字列に対するいくつかの演算が定義されている。

演算子 `+` で文字列と文字列を結合することができる。

```{code-cell}
s = 'aaa'
t = 'bbb'
s + t
```

演算子 `*` で文字列の繰り返しができる。

```{code-cell}
s = 'abc'
s * 5
```

## リスト

いくつかの値を並べたものを，まとめて一つのデータとして扱うことがある。
そのようなとき，**リスト**（list）を使うと便利である。

```{code-cell}
x = [85, 100, 90, 75]  # テストの点数
print(x)
```

リストに含まれるそれぞれの値のことを，リストの **要素**（element）とよぶ。

変数 `x` の値がリストであるとき，その要素にアクセスするには `x[0]`，`x[1]`，`x[2]` のように書けばよい。

```{code-cell}
print(x[0])
print(x[1] + x[2])
```

括弧 `[]` の中に書く数字を **添字**（index）とよぶ。リストの添字は `0` から始めることに注意すること。添字が大きすぎる場合はエラーが発生する。

```{code-cell}
:tags: [raises-exception]
print(x[3])
```

リストに含まれる要素の個数は，`len()` 関数を用いて求めることができる。

```{code-cell}
len(x)
```

リストに含まれる要素の合計は， `sum()` 関数を用いて求めることができる。

```{code-cell}
sum(x)
```

合計を要素数で割ることで平均を求めることができる。

```{code-cell}
sum(x) / len(x)
```

リストに要素を追加するには，`append()` を用いる。

```{code-cell}
a = []
a.append(100)
print('1回目:', a)
a.append(200)
print('2回目:', a)
a.append(300)
print('3回目:', a)
```

リストの末尾の要素を削除するには `pop()` を用いる。
第 `i` 番目の要素を削除するには `del` を用いる。 

```{code-cell}
a = [10, 20, 30, 40, 50]
print('最初のリスト:', a)
x = a.pop()
print('popされたのは:', x)
print('pop後のリスト:', a)
del a[1]
print('第1要素をdelした後のリスト:', a)
```

リストの末尾から数えて $i$ 番目の要素にアクセスするには `a[-1]` や `a[-2]` のように負の添字を用いることができる。このとき，`-1` が末尾の要素であり，`-2` が末尾から遡って数えて 2 番目の要素である。`-0` は `0` と等しく，負の数でない点に注意が必要である。

```{code-cell}
a = [10, 20, 30, 40, 50]
print('全体:', a)
print('末尾の要素:', a[-1])
print('末尾から2番目の要素:', a[-2])
```

要素数が $n$ 個のとき，$-n$ より小さい添字を指定するとエラーが発生する。

```{code-cell}
:tags: [raises-exception]
print('末尾から100番目の要素:', a[-100])
```

## スライス

文字列やリストのように何らかの値が並んだものを Python ではシーケンス型（sequence）とよぶ。

シーケンス型には他にも `tuple` や `bytes` などがある。
`range` オブジェクトのような，ジェネレータと呼ばれる特殊なものもある。

シーケンス型では「$i$ 番目の要素から $j$ 番目の要素の手前まで」のような範囲を指定して，部分列を指定することができる。

たとえば，`"Hello, world!"` という文字列のうち $1$ 文字目の `e` から $4$ 文字目の `o` までを取得するには

```{code-cell}
s = "Hello, world!"
s[1:5]
```

のように書けばよい。

コロン `:` の左／右に与える添字を省略すると，それぞれ先頭／末尾からすべてという意味になる。
つまり，

```{code-cell}
s = "Hello, world!"
print(s[:5])  # 先頭の 5 文字
print(s[5:])  # 先頭の 5 文字を除き，末尾まですべての文字
```

コロン `:` の左右に与える添字をどちらも省略すると，すべてという意味になる。
つまり，

```{code-cell}
s = "Hello, world!"
print(s[:])
```

```{note}
リスト `x` に対して `x[:]` はもとのオブジェクト `x` と同一のオブジェクトでなく，内容を複製した新しいオブジェクトとなる。このことから，`[:]` は簡易的な（浅い）コピーを生成するイディオムとして用いられることがある。
```

## 制御文

条件分岐をおこなうには `if` 文を用いる。

```{code-cell}
x = 12345
if x % 2 == 0:
    print(x, 'は 2 で割り切れます。')
elif x % 3 == 0:
    print(x, 'は 2 で割り切れませんが，3 で割り切れます。')
elif x % 5 == 0:
    print(x, 'は 2 でも 3 でも割り切れませんが，5 で割り切れます。')
else:
    print(x, 'は 2 でも 3 でも 5 でも割り切れません。')
```

次のプログラムは上のプログラムと似ているが，意味が大きく異なる。

```{code-cell}
x = 12345
if x % 2 == 0:
    print(x, 'は 2 で割り切れます。')
if x % 3 == 0:
    print(x, 'は 3 で割り切れます。')
if x % 5 == 0:
    print(x, 'は 5 で割り切れます。')
```

同じ命令を何度も繰り返して実行するには，`while` 文や `for` 文を用いる。
`while` 文は，与えた条件（以下では `x > 0`）が真（`True`）である限り繰り返す。
条件が偽になると繰り返しが終わるが，いつまでも真のままだと無限ループになってしまうため注意が必要である。

```{code-cell}
x = 12345
while x > 0:
    print(x, 'を 2 で割った余りは', x % 2, 'です。')
    x = x // 2
```

リストの要素ごとに同じ命令を繰り返すには `for` 文を用いる。

```{code-cell}
for x in [10, 20, 30]:
    print(x)
```

## モジュール

Python では，モジュールをインポートすることによって，さまざまな機能を追加で利用できるようになる。

たとえば数学の平方根・三角関数・対数関数や定数は `math` モジュールに含まれている。

```{code-cell}
import math
print('sqrt(7):', math.sqrt(7))
print('sin(pi/3):', math.sin(math.pi / 3))
print('log(10):', math.log(10))
print('pi:', math.pi)
print('e:', math.e)
```

```{note}
たびたび `math.` を付けるのは面倒である。
そのような場合は，次の例のように `from math import *` のように書くと `math.` を省略できる。`*` はワイルドカードとよばれる記号で，「すべて」を意味する。つまりここでは「`math` モジュールで定義されている識別子をすべてインポートせよ」という意味だと解釈できる。ただし，モジュール内で定義されている識別子が既存の識別子と一致する場合に問題が生じるかもしれない。
```

たとえば以下のような関数が提供されている。

- 三角関数
  - 正弦関数 $\sin x$: `sin(x)`
  - 余弦関数 $\cos x$: `cos(x)`
  - 正接関数 $\tan x$: `tan(x)`
  - 逆三角関数 $\arcsin x$，$\arccos x$，$\arctan x$: `asin(x)`，`acos(x)`，`atan(x)`，`atan2(y,x)`
  - 双曲線関数 $\sinh x$，$\cosh x$，$\tanh x$: `sinh(x)`，`cosh(x)`，`tanh(x)`
  - 逆双曲線関数 $\mathrm{arsinh}\; x$，$\mathrm{arcosh}\; x$，$\mathrm{artanh}\; x$: `asinh(x)`，`acosh(x)`，`atanh(x)`
- 指数関数 $e^x$: `exp(x)`
- 対数関数
  - 自然対数 $\log_e x$: `log(x)`
  - 常用対数 $\log_{10} x$: `log10(x)`
  - 二進対数 $\log_2 x$: `log2(x)`
  - 一般の対数関数 $\log_b x$: `log(x, base=b)`
- べき乗 $x^y$: `pow(x, y)`
- 平方根 $\sqrt{x}$: `sqrt(x)`
- 角度変換
  - ラジアン（弧度法）と度（度数法）の相互変換: `degrees(x)`，`radians(x)`
- その他
  - 天井関数 $\lceil x \rceil$: `ceil(x)`
  - 床関数 $\lfloor x \rfloor$: `floor(x)`
  - 絶対値 $|x|$: `fabs(x)` （`abs(x)` と違ってつねに `float` 型の値を返す）
  - 階乗 $n!$: `factorial(n)`
  - 順列 ${}_{n}P_{k}$ or $n \choose k$: `perm(n,k)` ※Python 3.8 以降
  - 組合せ ${}_{n}C_{k}$ or $n \choose k$: `comb(n,k)` ※Python 3.8 以降

ここに挙げた関数の多くは，[NumPy](https://numpy.org/) や [SciPy](https://scipy.org/) でも利用可能である。NumPy や SciPy は標準ライブラリではないが広く利用されている。特に NumPy は実用アプリケーションでも科学技術計算でも利用されるデファクトスタンダードと言っても過言ではない。

Python の標準ライブラリは Python 処理系をインストールしたときに合わせてインストールされる。標準ライブラリの一覧は[こちら](https://docs.python.org/ja/3/library/index.html)を参照されたい。

標準でないモジュールをインポートするには，追加でパッケージをインストールする必要がある。

```{note}
Python では，モジュール（module）は他のスクリプトから利用できる 1 つのファイルを表し，パッケージ（package）は複数のモジュールを 1 つのフォルダにまとめたものを表す。
パッケージをインストールする際はパッケージマネージャとよばれる種類のソフトウェアを用いるのが便利である。標準のパッケージマネージャ `pip` の他，使い勝手の良い `pipenv` や `poetry` などがよく利用される。
Python 処理系とパッケージマネージャをまとめて提供するディストリビューションで有名なのが Anaconda であり，そちらではパッケージマネージャとして `conda` を用いる。
```

たとえば標準的な方法で Python でインストールしてある場合， NumPy をインストールするには，OS 付属のコマンドラインインタフェース（Windows であればコマンドプロンプトや PowerShell，macOS であればターミナル）を開き，以下の命令を実行すればよい。

```
python -m pip install numpy
```

```{warning}
複数の Python がインストールされている場合は注意が必要。
始めの `python` コマンドを `python3` や `/usr/bin/python` などに置き換えて実行する必要がある。
```

もし NumPy がインストール済みであるならば，以下のようにして NumPy を利用することができる。

```{code-cell}
import numpy as np
np.__version__
```

慣習として，`numpy` をインストールするときはインポート文に `as np` 句を付ける。
これにより，`numpy` と書く代わりに短く `np` とだけ書けばよくなる。
